/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.raonsecure.odi;

import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import com.raonsecure.odi.agent.DIDManager;
import com.raonsecure.odi.agent.data.did.Proof;
import com.raonsecure.odi.agent.data.did.PublicKey;
import com.raonsecure.odi.agent.data.rest.KeyInfo;
import com.raonsecure.odi.agent.data.rest.ServiceInfo;
import com.raonsecure.odi.agent.data.rest.SignatureParams;
import com.raonsecure.odi.agent.enums.did.DIDKeyType;
import com.raonsecure.odi.agent.enums.did.DIDMethodType;
import com.raonsecure.odi.agent.enums.did.DIDStatus;
import com.raonsecure.odi.agent.enums.did.KeyPurpose;
import com.raonsecure.odi.agent.enums.did.ServiceType;
import com.raonsecure.odi.agent.exception.DIDManagerException;


public class DIDManagerTest {
	public DIDManager didManager = new DIDManager();
	List<SignatureParams> signatureParams = new ArrayList<SignatureParams>();
	
	private String genDIDTest() throws DIDManagerException {
		DIDManager didManager = new DIDManager();
		return didManager.genDID("omn", "das"); // did method와 계정명 입력
	}
    
	@DisplayName("create dids")
	@Test
	public void makeDIDDocumentTest() throws DIDManagerException {
	
		List<KeyInfo> keyInfos = new ArrayList<>();
		String did = genDIDTest();
		// 월렛 서버로부터 키 요청
		// 받은 키 리스트를 가지고 keyInfo에 담아 keyInfos 세팅
		// 현 테스트 코드에서는 하드코딩으로 keyId를 "assert1, auth1, keyagree, invoke"로 keyInfo 세팅

		// assertionMethod 키 정보
		KeyInfo keyInfo1 = new KeyInfo();
		keyInfo1.setKeyId("assert1");
		keyInfo1.setAlgoType("Secp256r1");
		keyInfo1.setPublicKey("zvXsXFNahfw9Cz4KQEdLjBtoUEUiVHoMxWs23j6axNuTP");
		keyInfo1.setMethodType(DIDMethodType.ASSERTION_METHOD.getRawValue()); // 1 - assertionMethod
		keyInfo1.setController(did);
		keyInfos.add(keyInfo1);

		// authentication 키 정보
		KeyInfo keyInfo2 = new KeyInfo();
		keyInfo2.setKeyId("auth1");
		keyInfo2.setAlgoType("Secp256r1");
		keyInfo2.setPublicKey("z21Fy2h5uqmhw8xSVxBXNtBbVVjPTuKMam8ebz2FR7CD62");
		keyInfo2.setMethodType(DIDMethodType.AUTHENTICATION.getRawValue()); // 2 - authentication
		keyInfo2.setController(did);
		keyInfos.add(keyInfo2);

		// keyagreement 키 정보
		KeyInfo keyInfo3 = new KeyInfo();
		keyInfo3.setKeyId("keyagree");
		keyInfo3.setAlgoType("Secp256r1");
		keyInfo3.setPublicKey("znByKCSPznGAKc48CF7i7BhWuhEnz2U7sU4m5TxTrJVEf");
		keyInfo3.setMethodType(DIDMethodType.KEY_AGREEMENT.getRawValue()); // 4 : keyagreement
		keyInfo3.setController(did);
		keyInfos.add(keyInfo3);

		// capabilityInvocation 키 정보
		KeyInfo keyInfo = new KeyInfo();
		keyInfo.setKeyId("invoke");
		keyInfo.setAlgoType("Secp256r1");
		keyInfo.setPublicKey("z26c1jGCoQa2gpuUxGifkkpwgmndSGUH5Ma6fCsxcg9XiX");
		keyInfo.setMethodType(DIDMethodType.CAPABILITY_INVOCATION.getRawValue()); // 8 : capabilityInvocation
		keyInfo.setController(did);
		keyInfos.add(keyInfo);

		// 3. DID 문서 생성. service 정보 필요시 객체 생성하여 추가(addServiceTest 메소드 참고)
		didManager.makeDIDDocument(did, keyInfos, null);

	}
//	
	@DisplayName("add service")
    @Test 
	public void addServiceTest() throws DIDManagerException {
		this.makeDIDDocumentTest();
		ServiceInfo serviceInfo1 = new ServiceInfo(); // serviceEndpoint, type 세팅 필요
		List<String> serviceUrlList1 = new ArrayList<String>();
		serviceUrlList1.add("https://did.omnione.net");
		serviceInfo1.setServiceUrl(serviceUrlList1);
		serviceInfo1.setServiceType(ServiceType.LINKED_DOMAINS); // LINKED_DOMAINS, LINKED_DOCUMENT 서비스 타입으로 serviceID
																	// 자동 생성

		ServiceInfo serviceInfo2 = new ServiceInfo();
		List<String> serviceUrlList2 = new ArrayList<String>();
		serviceUrlList2.add("https://did.omnione.net/ld/certificate/1234");
		serviceInfo2.setServiceUrl(serviceUrlList2);
		serviceInfo2.setServiceType(ServiceType.LINKED_DOCUMENT);

		didManager.addService(serviceInfo1);
		didManager.addService(serviceInfo2);

	}
	
	@DisplayName("add key")
	@Test
	public void addKeyTest() throws DIDManagerException {
		addServiceTest();
		// 월렛 서버로 부터 추가한 키 정보를 요청
		// 받은 키 정보를 토대로 keyInfo 세팅

		// assertionMethod 키 정보
		KeyInfo keyInfo = new KeyInfo();
		keyInfo.setKeyId("auth2"); // 키아이디
		keyInfo.setAlgoType("Secp256r1"); // 알고리즘타입
		keyInfo.setPublicKey("znftWnySNYebacUJvtmuBx8mur5aA8ZmELfegpSMmvStC"); // 인코딩된공개키
		keyInfo.setMethodType(DIDMethodType.AUTHENTICATION.getRawValue()); // 1 - assertionMethod
		keyInfo.setController(didManager.getDIDDocument().getController());

		didManager.addKey(keyInfo);

	}
    
	@DisplayName("get req signature param")
    @Test
	public void getSignatureParamsTest() throws DIDManagerException {
		addKeyTest();
		// 1. 서명 요청할 keyID 리스트 생성
		List<String> keyIds = new ArrayList<String>();
		keyIds.add("assert1");
		keyIds.add("auth1");
		keyIds.add("invoke");

		// 2. 서명 요청할 객체 생성
		signatureParams = didManager.getSignatureParams(keyIds);

	}

	@DisplayName("add proof")
    @Test 
	public void addProofTest() throws DIDManagerException {
		this.getSignatureParamsTest();

		// getSignatureParams() 에서 생성한 객체를 월렛 서버로 전송
		// 월렛 서버에서 각 key에 맞게 서명값 추가하여 리턴
		List<SignatureParams> tmpSignatureParams = new ArrayList<SignatureParams>();
		int i = 0;
		for (SignatureParams singlePram : signatureParams) {
			i++;
			singlePram.setSignatureValue("signatureValue.." + i);
			tmpSignatureParams.add(singlePram);
		}
		// 서명값이 추가된 서명 객체를 Proof 객체로 DID 문서에 추가
		didManager.addProof(tmpSignatureParams);

	}
    
	@DisplayName("get req signature verify param")
    @Test
    public void getVerifySignatureParamsTest() throws DIDManagerException {
    	this.getSignatureParamsTest();
    	List<SignatureParams> signatureParams = new ArrayList<SignatureParams>();
    	
    	// Proof 검증을 위해 원문 객체 추출
    	signatureParams = didManager.getVerifySignatureParams();
//		
//		for(SignatureParams signList : signatureParams) {
//	    	System.out.println("원문 ::: "+signList.getData());
//	    	System.out.println("publicKey ::: "+signList.getPublicKey());
//	    	System.out.println("sign ::: "+ signList.getSignatureValue());
//	    	System.out.println("algo ::: "+ signList.getAlgString());
//		}
    }
    
  
    @Test
	public void removeKeyTest() throws DIDManagerException {
		this.getVerifySignatureParamsTest();

		didManager.removeKey("auth2");

	}
//    @Test
//    public void removeLinkTest() {
//    	try {
//    		System.out.println("===removeLinkTest===");
//			didManager.removeLink("auth2",DIDMethodType.AUTHENTICATION); // 키아이디와 메소드타입(enum)
//			System.out.println(didManager.getDIDDocument().toJson());
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    	
//    }
//    
//    @Test
//    public void checkMethodTypeTest() {
//    	// 메소드타입별 한개씩 링크되어있는 상태. keyids : [assert1, auth1, keyagree, invoke]
////    	String keyid = "wrongKey";
//    	String keyid = "auth1";
//    	DIDMethodType type = DIDMethodType.AUTHENTICATION;
//    	boolean result = didManager.checkMethodType(keyid, type);
//    	System.out.println(keyid+"키가 "+type+"메소드 포함 체크 : "+ result);
//    }
//    
//    @Test
//    public void getSignableKeyIdsTest(){
//    	try {
//    		List<String> keyIds = new ArrayList<String>();
//			keyIds = didManager.getSignableKeyIds(); // did 문서 내 keyagreement 타입을 제외한 서명가능한 키 체크
//			
//			System.out.println(keyIds);
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    }
//    
//    @Test
//    public void getLinkValuesTest(){
//    	DIDMethodType type = DIDMethodType.AUTHENTICATION; // 링크를 찾으려는 메소드타입 선택
//    	try {
//    		List<String> links = new ArrayList<String>();
//    		links = didManager.getLinkValues(type); // 지정된 타입에 링크된 모든 키 출력
//			
//			System.out.println(links);
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    }
//    
//    @Test
//    public void getPublicKeyTest() {
//    	PublicKey pubkey = new PublicKey();
//    	try {
//			pubkey = didManager.getPublicKey("auth1"); // 키아이디로 공개키 정보 획득
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    	System.out.println("multibasePubKey : "+pubkey.getPublicKeyMultibase());//공개키 정보 출력 예시
//  
//    }
//    
//    @Test
//    public void getLinkedFieldTest() {
//    	
//    	try {
//    		// 새로운 키 추가
//    		KeyInfo keyInfo = new KeyInfo();
//        	keyInfo.setKeyId("key10");
//        	keyInfo.setController(didManager.getDIDDocument().getController());
//        	keyInfo.setAlgoType("Secp256r1");
//        	keyInfo.setMethodType(1); // ASSERTION_METHOD로 추가
//        	keyInfo.setPublicKey("pubkeyExample");
//    		
//    		didManager.addKey(keyInfo);
//    		
//    		//새로운 키의 링크 추가
//    		didManager.addLink(didManager.getDIDDocument().getController()+"#key10", 2); // AUTHENTICATION 링크 추가
//    		didManager.addLink(didManager.getDIDDocument().getController()+"#key10", 8); // CAPABILITY_INVOCATION 링크추가
//    		System.out.println(didManager.getDIDDocument().toJson());
//    		
//    		//테스트 결과 확인
//			System.out.println(didManager.getLinkedField("key10"));
//			
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    }
//    
//    @Test
//    public void getStatusTest() {
//    	try {
//			didManager.changeStatus("assert1", DIDStatus.REVOKED);
//			System.out.println(didManager.getStatus("assert1"));
//    	}catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//    }
//    
//    @Test
//    public void changeStatusTest() {
//    	try {
//			didManager.changeStatus("assert1", DIDStatus.REVOKED);
//			System.out.println(didManager.getDIDDocument().toJson());
//		} catch (DIDManagerException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}    	
//    }
//    
//    @Test
//    public void generateManagementProofTest() {
//    	Proof proof = new Proof();
//    	proof = didManager.generateManagementProof(didManager.getDIDDocument().getController()+"#assert1", KeyPurpose.ASSERTION_METHOD);
//    	System.out.println(proof.toJson());
//    }
}
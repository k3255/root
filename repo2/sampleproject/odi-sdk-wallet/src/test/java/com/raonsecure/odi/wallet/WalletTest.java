/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.raonsecure.odi.wallet;

import java.io.UnsupportedEncodingException;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import com.raonsecure.odi.crypto.digest.Sha256;
import com.raonsecure.odi.crypto.enums.MultiBaseEnum;
import com.raonsecure.odi.crypto.exception.CryptoException;
import com.raonsecure.odi.crypto.key.data.AESType;
import com.raonsecure.odi.crypto.util.MultiBase;
import com.raonsecure.odi.wallet.exception.IWException;
import com.raonsecure.odi.wallet.key.IWKeyManager;
import com.raonsecure.odi.wallet.key.IWKeyManagerInterface.OnConnectListener;
import com.raonsecure.odi.wallet.key.data.IWKey.ALGORITHM_TYPE;
import com.raonsecure.odi.wallet.util.SignatureUtil;

public class WalletTest {
	private static String password = "1234";
	private static IWKeyManager keyManager;

	@DisplayName("create wallet and unLock(connect)")
	@Test
	public void makeKeyStore() throws IWException {

		keyManager = new IWKeyManager(password.toCharArray(), AESType.AES256);
		keyManager.unlock(password.toCharArray(), new OnConnectListener() {
			@Override
			public void onSuccess() {

			}

			@Override
			public void onFail(String errCode) {

			}

			@Override
			public void onCancel() {

			}
		});

	}

	@DisplayName("key generation")
	@Test
	void generateRandomKeyTest() throws IWException {

		makeKeyStore();
		keyManager.generateRandomKey("assert1", ALGORITHM_TYPE.ALGORITHM_SECP256r1.getValue());
		keyManager.generateRandomKey("auth1", ALGORITHM_TYPE.ALGORITHM_SECP256r1.getValue());
		keyManager.generateRandomKey("keyagree", ALGORITHM_TYPE.ALGORITHM_SECP256r1.getValue());
		keyManager.generateRandomKey("invoke", ALGORITHM_TYPE.ALGORITHM_SECP256r1.getValue());

	}

	@DisplayName("signatures and verification")
	@Test
	void getSignVerifySignTest() throws IWException, UnsupportedEncodingException, CryptoException {

		makeKeyStore();
		generateRandomKeyTest();

		String source = "verify";
		SignatureUtil signatureUtil = new SignatureUtil();

		byte[] singedData = keyManager.getSign("assert1", source.getBytes("utf-8"));

		signatureUtil.verifySign(keyManager.getPublicKey("assert1"), source,
				MultiBase.encode(singedData, MultiBaseEnum.Base58btc), "Secp256r1");

	}

	@DisplayName("signatures and verification with hash value")
	@Test
	void verifySignWithHashDataTest() throws IWException, UnsupportedEncodingException, CryptoException {

		makeKeyStore();
		generateRandomKeyTest();

		String source = "verify";
		SignatureUtil signatureUtil = new SignatureUtil();

		byte[] singedData = keyManager.getSignWithHashData("assert1", Sha256.from(source.getBytes("utf-8")).getBytes());

		signatureUtil.verifySignWithHashData(keyManager.getPublicKey("assert1"),
				MultiBase.encode(Sha256.from(source.getBytes("utf-8")).getBytes(), MultiBaseEnum.Base16),
				MultiBase.encode(singedData, MultiBaseEnum.Base58btc), "Secp256r1");

	}

	@DisplayName("re-connect")
	@Test
	void reConnectTest() throws IWException {
		makeKeyStore();
		keyManager.disConnect();
		keyManager.unlock(password.toCharArray(), new OnConnectListener() {
			@Override
			public void onSuccess() {

			}

			@Override
			public void onFail(String errCode) {

			}

			@Override
			public void onCancel() {

			}
		});
	}
}
